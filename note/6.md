# 表达式

rust是表达式语言。

在 C 中，if 和 switch 是语句，它们不生成值，也不能在表达式中间使用。

而在 Rust 中，if 和 match 可 以生成值：

```rust
fn main() {
    let num = 80;
		
  	// Rust中不需要三元运算符（expr1 ? expr2 : expr3）
    let result =
        if num > 100 {
            "large number"
        } else {
            "small number"
        };
    println!("{}", result);  // small number

  	// Rust 禁止未覆盖所有可能值的match表达式
    let another_result = match num {
        80 => "eighty",
        100 => "one hundred",
      	// _ 类似switch中的default，必须排在最后
        _ => "None"
    };
    println!("{}", another_result);  // eighty
}
```

## 块

块是一种最通用的表达式。一个块生成一个值：

```rust
fn main() {
    let result = {
        let a = 1;
        let b = 2;
        // 当块的最后一行不带分号时，那个就是块的值
        a + b
    };
    
    println!("{}", result); // 3
    
  	// 遮蔽 前面相同名字的变量
    let result = {
        println!("empty block");
        // 这个块没有明确指定返回值，那返回值就是 ()
    };
    
    println!("{:?}",  result); // ()
}
```

## for

```rust
fn main() {
    // [0, 20), 不包含20
    for i in 0..20 {
        println!("{}", i)
    }
}
// .. 运算符会生成一个范围（range），即具有两个字段（start 和 end）的简单结构体。
// 0..20 与 std::ops::Range { start: 0, end: 20 } 相同
```

```rust
fn main() {
    let mut cnt = 0;

    let result = loop {
        cnt += 1;

        if cnt > 10 {
            // 在 break 后面跟一个表达式，该表达式的值会成为此 loop 的值
            break cnt;
        }
    };

    println!("{}", result);  // 11
}
```

```rust
fn main() {
    let chars = vec!['A', 'B', 'C'];

    // 定义一个label
    'outer:
    for ch in chars {
        for i in 0..10 {
            println!("{} -- {}", ch, i);

            if i > 5 {
                // 默认只能跳出内部循环，利用label直接跳出外部循环
                break 'outer;
            }
        }
    }
}
```

## return

不带值的 `return` 是 `return ()` 的简写。

函数不必有明确的 return 表达式。函数体的工作方式类似于块表达式：如果最后一个表达式后没有分号， 则它的值就是函数的返回值。

## 类型转换

```rust
fn main() {
    let byte_number: u8 = 10;

    // let short_number : u16 = byte_number; // Type mismatch [E0308] expected `u16`, but found `u8`
    let short_number: u16 = byte_number as u16;

    println!("{}", short_number);

    let big_number = 257;
    // 注意下面byte_number是创建了一个新的变量，它 遮蔽 了上面的同名变量
    let byte_number = big_number as u8;
    println!("{}", byte_number);  // 1, 截断之后的值
}
```

