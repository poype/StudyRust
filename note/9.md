# Crate

在Cargo.toml 文件中指定了我们想要的每个 crate 的版本。

```rust
[package]
name = "StudyRust"
version = "0.1.0"
edition = "2024"   // rust 语言的版本，确定使用哪个版本的 Rust 语法

[dependencies]
axum = "0.7"  // 只指定了主版本号 0.7, 但 Cargo 会自动选择 0.7.x 系列中最新的兼容版本
tokio = { version = "1", features = ["full"] }
serde = { version = "1", features = ["derive"] }
```

`dependencies`指定这个项目使用的其他`crate`，也就是我们所依赖的代码。

Tokio 是一个功能丰富的异步运行时，但不是所有项目都需要所有功能。通过 **features** 可以：

- 减少编译时间 ：只编译需要的功能
- 减少二进制文件大小 ：不链接不需要的代码
- 按需启用 ：只使用需要的功能

```rust
// 方式 1：表格式（推荐）
tokio = { version = "1", features = ["full"] }

// 方式 2：简化写法（不推荐，功能不明确）
tokio = "1"  // 只会启用最小功能，可能不够用

// features = ["full"] 会启用 tokio 的 大部分常用功能 ，但不是绝对的"所有"功能。
// 生产环境建议明确指定需要的 features，减少编译时间和二进制大小，这时就不用使用 full 了。
```

```rust
serde = { version = "1", features = ["derive"] }

// 使用 derive 宏（推荐）, 但需要启用 "derive" feature
#[derive(Deserialize, Serialize)] 
struct User {
    name: String,
    age: u32,
}

// 不需要 derive feature，但代码冗长
struct User {
    name: String,
    age: u32,
}
impl Serialize for User {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        // 手动实现序列化逻辑...
    }
}
```

**Features ：Rust 的条件编译机制，允许按需启用功能**。



运行`cargo build`时，Cargo 首先会从 crates.io 下载这些 crate 的指 定版本的源代码。然后，它会读取这些 crate 的 Cargo.toml 文件、进而再下载它们的依赖项，并递归地执行这个流程。

所有依赖关系的集合，会告诉 Cargo 关于要构建什么 crate 以及应该按什么顺序构建的全部知识， 这叫作该 crate 的**依赖图**。Cargo 对**依赖图**和**传递依赖**的自动处理可以显著节省程序员的时间和精力。

一旦有了源代码，Cargo 就会编译所有的 crate。它会为项目依赖图中的每个 crate 都运行一次 rustc。

编译**库**时，Cargo 会使用`--crate-type lib`选项。这会告诉 rustc 不要寻找 main() 函数， 而是生成一个 .rlib 文件，其中包含一些已编译代码，可用于创建二进制文件和其他 .rlib 文件。

编译**程序**时，Cargo 会使用`--crate-type bin`，结果是目标平台的二进制可执行文件，比如 Windows 上 的 exe。

对于每个 rustc 命令，Cargo 都会传入`--extern`选项，给出 crate 将使用的每个库的文件名。
这样，当 rustc 看到一行代码（如 `use image::png::PNGEncoder`）时，就可以确定 image 是另一个 crate 的名称。
感谢 Cargo，它知道在哪里可以找到磁盘上已编译的 crate。
Rust 编译器需要访问这些 .rlib 文件，因为它们包含库的**已编译代码**。Rust 会将代码**静态链接**到最终的可执行文件中。



