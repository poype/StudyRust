# 线程

Rust中标准库使用`1:1`的线程实现模型，即Rust语言中的一个线程对应操作系统中的一个线程。

thread::spawn接受一个闭包作为参数，会创建一个新的线程执行闭包中的code：
```rust
use std::thread;
use std::time::Duration;

fn main() {
    thread::spawn(|| {
        for i in 1..10 {
            println!("number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(10));
        }
    });

    for i in 1..10 {
        println!("number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(10));
    }

    // 如果主Thread退出了，即使子Thread没执行完，进程也会立刻退出，这里等待2s给子线程一些时间
    thread::sleep(Duration::from_millis(2000));
}
```

### join

```rust
fn main() {
    let join_handle = thread::spawn(|| {
        for i in 1..10 {
            println!("number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(10));
        }
    });

    for i in 1..10 {
        println!("number {} from the main thread!", i);
    }

    // join方法使main thread在这里等待子线程执行完再继续
    join_handle.join().unwrap();
}
```


### move

问题：
```rust
fn main() {
    let v = vec![1, 2, 3];

    // 报错：may outlive borrowed value `v`
    // 闭包会尝试借用变量v，rust没法确定子线程会运行多久，不确定对变量v的引用是否会一直有效，所以只能报错。
    let join_handle = thread::spawn(|| {
        println!("spawn thread: {:?}", v);
    });

    join_handle.join().unwrap();
}
```

增加move关键字解决问题：
```rust
fn main() {
    let v = vec![1, 2, 3];

    // 增加move关键字将变量v的所有权转交给子线程
    // ------- value moved into closure here
    let join_handle = thread::spawn(move || {
        println!("spawn thread: {:?}", v);
    });

    // value borrowed here after move
    // println!("main thread: {:?}", v);
    join_handle.join().unwrap();
}
```
