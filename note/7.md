# 错误处理

**Result** 通常用以表示由程序外部的事物引发的错误，比如错误的输入、网络中断或权限问题。这些错误在没有任何 bug 的程序中也可能会不时出现。

**panic** 针对的是那种**永远不应该发生**的错误，即程序存在Bug。

## panic

panic类似 Java 中的 RuntimeException。一个线程 panic 时，其他线程不受影响。

```rust
use std::io;

fn main() {
    println!("Please input a number：");
    let mut input = String::new();

    let result: Result<usize, io::Error> = io::stdin().read_line(&mut input);
    if result.is_err() {
        println!("read number fail");
        return;
    }

    let cnt = result.expect("extract cnt fail");
    if cnt < 3 {
        // 字符串长度小于3，就抛异常，这会终止当前线程
        panic!("the number you input is too small");
    }

    println!("The number you input is {}", input);
}

/*
当输入字符串长度小于3时，会得到如下的错误：

thread 'main' (1218954) panicked at src/main.rs:15:9:
the number you input is too small
stack backtrace:
   0: __rustc::rust_begin_unwind
             at /rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/std/src/panicking.rs:698:5
   1: core::panicking::panic_fmt
             at /rustc/ded5c06cf21d2b93bffd5d884aa6e96934ee4234/library/core/src/panicking.rs:80:14
   2: StudyRust::main
             at ./src/main.rs:15:9
   3: core::ops::function::FnOnce::call_once
             at /Users/fordev/.rustup/toolchains/stable-aarch64-apple-darwin/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
 */
```

## Result

```rust
use std::{fs};

fn main() {
    const FILE_PATH: &str = "/Users/fordev/Workspace/StudyRust/src/main.rs";

    // 相当于java中的try-catch
    match fs::read_to_string(FILE_PATH) {
        Ok(content ) => {
            println!("read file success, the content is \n {}", content);
        }
        Err(err) => {
            println!("read file fail, err: {}", err);
        }
    }
}
```

Result是一个Enum，Ok 和 Err 是它的成员。

Result提供的其它API：

```rust
use std::{fs};
use std::io::Error;

fn main() {
    const FILE_PATH: &str = "/Users/fordev/Workspace/StudyRust/src/main.rs";

    let result: Result<String, Error> = fs::read_to_string(FILE_PATH);

    println!("{}", result.is_ok());
    println!("{}", result.is_err());

    let option_value: Option<String> = result.ok();
    // 方法1：if let 匹配Some(值)，直接提取（新手首选，简洁）
    if let Some(content) = option_value {
        println!("content：\n{}", content);
    } else {
        println!("the content is none");
    }
}
```

## if let

`if let` 最核心、最原生的设计目的，就是**用于从枚举中匹配单个变体并提取其内部值**，是 Rust 为了**简化**枚举模式匹配设计的专属语法。

从option_value中提取值最直接的方式：

```rust
// 这里的Some(content)就是模式
match option_value {
    Some(content) => println!("content：{}", content),
    None => println!("the content is none"),
}
```

而`if let Some(content) = option_value`，本质就是 **`match`的 “单分支简化版”**，Rust 设计这个语法的目的，就是为了避免为了匹配**一个枚举变体 **，还要写完整的`match`代码（冗余）。

```rust
// 判断option_value能否匹配上左边的模式Some(content), 
// 如果匹配成功时，Rust会执行 “隐式的变量定义”，把Some包裹的值赋给content
if let Some(content) = option_value {
    println!("content：\n{}", content);
} else {
    println!("the content is none");
}

// 这里的let不是定义变量，if let具有整体的含义：从枚举变体中提取值并绑定到变量
```

## 传播错误

让**调用者**去处理错误，希望错误沿着调用栈向上传播。

```rust
use std::{fs};
use std::io::Error;

fn main() {
    let result = test_error_propagation();
    // 如果发生错误，在最外层函数进行处理
    if result.is_err() {
        println!("inner method fail, err: {}", result.err().expect("extract error fail"))
    }
}

fn test_error_propagation() -> Result<String, Error> {
  	// 用 _ 可以忽略错误
    // use `let _ = ...` to ignore the resulting value
    test()
}

fn test() -> Result<String, Error> {
    const FILE_PATH: &str = "/Users/fordev/Workspace/StudyRust/src/main.rs";

    // 注意后面加了 ?
    // the `?` operator can only be used in a function that returns `Result` or `Option`
    let content = fs::read_to_string(FILE_PATH)?;

    println!("content: \n {}", content);

    Ok("no error".to_string())  // 必须要返回一个值
}
```

? 的行为取决于此函数是返回了成功结果还是错误结果：

1. 如果是成功结果，那么它会解包 Result 以获取其中的成功值。
2. 如果是错误结果，那么它会立即从所在函数返回，将错误结果沿着调用链向上传播。? 只能在返回类型为 Result 的函数中的 Result 值上使用。

? 的作用与下面的代码类似：
```rust
let weather = match get_weather(hometown) {
	Ok(success_value) => success_value,
	Err(err) => return Err(err)   // 注意这里的return 
};
```

在返回 Option 类型的函数中，也可以使用 ? 解包某个值，这样当遇到 None 时就会提前返回。

## 处理main()中的错误

`main()` 不能使用 ?，因为它的返回类型不是 Result。

处理 main() 中错误的最简单方式是使用 `.expect()`：

```rust
fn main() {
		calculate_tides().expect("error"); // 责任止于此
}
```

如果`calculate_tides()`返回错误结果，那么`.expect()`方法就会 panic。





